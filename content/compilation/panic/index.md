+++
title = "panic!"
weight = 1

[extra]
+++

Rust 的 `panic!` 主要做到：

1. 立刻停止目前執行路徑（像丟出一個「不可恢復」的錯誤訊號）
2. 預設會 **堆疊回溯 stack unwinding** ，以及沿途呼叫已建構物件的 Drop，釋放資源、解鎖 mutex、關檔案等
3. 如果沒有人接住，最後程式會終止
4. 或是透過 `std::panic::catch_unwind(...)` 接住，把 panic 當成例外捕捉，避免整個程序死掉

C 沒有語言內建的 stack unwinding + RAII drop，所以你只能用幾種「類似」的機制去拼出相近語意。

常見選項：

| 機制                      | 行為特性                                   | 清理行為                                                                   | 與 Rust `panic!` 的關係                               | 適合使用情境                                     |
|---------------------------|--------------------------------------------|----------------------------------------------------------------------------|-------------------------------------------------------|--------------------------------------------------|
| **A. `abort()`**          | 立即非正常終止程式，通常產生 core dump     | 幾乎不做任何清理，不會執行 `atexit` handler（平台行為略有差異）            | **最像 `panic = abort`**                              | 這種狀況「不該發生」，資料結構已損壞，越快死越好 |
| **B. `exit(code)`**       | 宣告失敗後正常結束程式                     | 會執行 `atexit` handler、關閉 stdio buffer，但不會自動釋放 `malloc` 記憶體 | 類似「顯式失敗退出」，**不是 unwind**                 | CLI 工具啟動失敗、設定檔不可用                   |
| **C. `assert(expr)`**     | 開發期炸掉程式，印訊息後通常呼叫 `abort()` | 同 `abort()`                                                               | 開發期的 panic 檢查（Release 可能被移除）             | 內部不變量檢查、「理論上不會到這裡」             |
| **D. `setjmp / longjmp`** | 非區域跳躍，可模擬丟出 / 捕捉錯誤          | ❌ 不會自動清理資源（需手動回滾、釋放、解鎖）                               | **最像「unwind 但沒有 `Drop`」**，接近 `catch_unwind` | 框架邊界層：錯誤中止流程但讓程式繼續活著         |